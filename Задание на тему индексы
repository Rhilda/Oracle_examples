
CREATE TABLE Phonebook
    (
     ID             NUMBER   (6)       NOT NULL, 
     FIRST_NAME     VARCHAR2 (20 BYTE)     NULL, -- имя
     LAST_NAME      VARCHAR2 (25 BYTE)     NULL, -- фамилия
     MIDDLE_NAME    VARCHAR2 (50 BYTE)     NULL, -- отчество
     EMAIL          VARCHAR2 (50 BYTE)     NULL, -- емайл
     PHONE_NUMBER   VARCHAR2 (20 BYTE)     NULL, -- телефон
     BIRTHDATE      DATE      		   NULL, -- Дата рождения
     TAXID          NUMBER(12)             NULL  -- ИНН
    ) NOLOGGING
;


I. Написать pl/sql-код по созданию индексов:
	Имя индекса определяется так:
		IX_(название таблицы)_(наименование поля 1 входящий в индекс)_(наименование поля 2 входящий в индекс)
		Например,
		IX_PhoneBook_BIRTHDATE_TAXID
	либо так:
		IX_(название таблицы)_(наименование поля 1 входящий в индекс)_(наименование поля 2 входящий в индекс)_(incl)_(наименование столбца, по которому не создается индекс, но входит в него)
		Например,
		IX_PhoneBook_BIRTHDATE_TAXID_INCL_MIDDLE_NAME

Базовые индексы:
1) не кластерный индекс для быстрого поиска записи, если входящий параметр для поиска: фамилия (всегда)

create index IX_PhoneBook_LAST_NAME
on PhoneBook(LAST_NAME);

2) не кластерный индекс для быстрого поиска емайл,  если входящий параметр для поиска: фамилия (всегда)

create index IX_PhoneBook_LAST_NAME_INCL_EMAIL
on PhoneBook(LAST_NAME, EMAIL);

3) не кластерный индекс для быстрого поиска записи, если входящий параметр для поиска: фамилия (всегда), имя (всегда), отчество (иногда).

create index IX_PhoneBook_LAST_NAME_FIRST_NAME_MIDDLE_NAME
on PhoneBook(LAST_NAME, FIRST_NAME, MIDDLE_NAME);

4) не кластерный индекс для быстрого поиска - "ИНН",если входящий параметр для поиска: фамилия (всегда), имя (всегда), отчество (иногда).

create index IX_PhoneBook_LAST_NAME_FIRST_NAME_INCL_TAXID
on PhoneBook(LAST_NAME, FIRST_NAME, TAXID);

Продвинутые индексы:
5) не кластерный индекс для быстрого поиска - "Дата рождения", без обращения к кластерному индексу, если входящий параметр для поиска: фамилия (всегда), имя (иногда), отчество (иногда).

create index IX_PhoneBook_LAST_NAME_INCL_BIRTHDATE
on PhoneBook(LAST_NAME, BIRTHDATE);

6) не кластерный индекс для быстрого поиска - "ID", без обращения к кластерному индексу, если входящий параметр для поиска: ИНН (всегда), телефон (иногда).

create index IX_PhoneBook_TAXID_INCL_ID
on PhoneBook(TAXID, ID);

Индексы, где нужно серьезно подумать и написание обоснование на создание индекса или НЕ создание индекса: 
7)    кластерный индекс для быстрого поиска - "ИНН", если входящий параметр для поиска: фамилия (всегда), имя (всегда), отчество (иногда).

Создание кластерного индекса по полю "ИНН" возможно, при условии, что там не будет дубликатов. В ином случае,
предпочтительней создать кластерный индекс на суррогатный первичный ключ(id). Также будет полезно создать не кластерный
индекс на поля: фамилия, имя, отчество.

8)    создать второй кластерный индекс для поиска записи, если входящий параметр для поиска: - "фамилия".

Кластерный индекс может быть только один на таблицу, поэтому создать второй кластерный индекс невозможно.

9)    не кластерный индекс для быстрого поиска записи, если входящий параметр для поиска: фамилия (иногда), имя (иногда), отчество (иногда), ИНН (иногда), телефон (иногда), дата рождения (иногда).

Создание подобного индекса не разумно, потому что, во-первых, слишком большое кол-во полей(нерациональное использование памяти,
потеря производительности при изменениях таблицы), во-вторых, все эти поля используются при поиске иногда(т.е. может
такое случится, что при запросе не сработает индекс, если не указать поля в порядке их объявления в индексе).

II. Написать pl/sql-код для индекса под номером: 2 и 4, который снизит дефрагметацию индекса в 0, то есть перестроить индекс 2 и 4.

ALTER INDEX IX_PhoneBook_LAST_NAME_INCL_EMAIL REBUILD ONLINE;

ALTER INDEX IX_PhoneBook_LAST_NAME_FIRST_NAME_INCL_TAXID REBUILD ONLINE;



